+++
title = "7日刷题第三天"
date = 2025-04-26T13:02:12+08:00
draft = false
description = ""
subtitle = "之动态规划题型总结"
header_img = ""
short = false
toc = true
tags = []
categories = ["计算机"]
series = ["面试", "算法题"]
comment = false
summary = ""
+++

# 开始


## 一、动态规划 vs 回溯的核心区别

| 项目           | 动态规划（DP）                             | 回溯（Backtracking）                      |
|----------------|--------------------------------------------|-------------------------------------------|
| 解决问题类型   | 最值、计数问题（如最短路径、最大和）       | 组合、排列、子集（所有解 or 某一个解）   |
| 是否记忆状态   | ✅ 需要记忆（用数组、哈希表）              | ❌ 不记忆，一条路径走到底再撤回            |
| 是否剪枝       | 一般不剪                                    | 常剪枝，尤其是排序 + 剪枝策略             |
| 适用场景       | 子问题有重叠，最优子结构                   | 需要尝试所有可能的决策路径                 |
| 常用结构       | `dp[i][j]` 或 `dp[i]` 表格或滚动数组       | 递归 + 路径path + 选择列表 + 回溯          |


## 二、回溯问题模板（组合类、排列类、子集类）

```cpp
vector<vector<int>> result;
vector<int> path;

void backtrack(参数...) {
    if (终止条件) {
        result.push_back(path);
        return;
    }

    for (选择 : 可选列表) {
        做选择（path.push_back）
        递归 backtrack(...)
        撤销选择（path.pop_back）
    }
}
```

### 应用：
- **组合**：`for (int i = start; i < nums.size(); i++)`，要剪枝
- **排列**：`for (int i = 0; i < nums.size(); i++)`，加 visited 数组去重
- **子集**：不用剪枝，直接 i+1 枚举所有子集


## 三、动态规划五步法（适用于刷“最值型”问题）

1. **确定状态**：一般是用一个维度或者二维维度表示子问题。
2. **确定选择**：从哪些状态转移过来？做什么操作？
3. **定义 dp 数组含义**：`dp[i]` 表示什么？如：到 i 的最大和。
4. **初始化**：根据问题逻辑给出基础值。
5. **状态转移方程**：写出 `dp[i] = max/min/...` 的转移公式。

### 应用例子：
- **01 背包**：`dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i]] + value[i])`
- **打怪升级题**（状态压缩 DP）：`dp[state]`，`state` 用 bitmask 表示已经完成哪些任务
- **股票问题**：`dp[i][k][0/1]` 表示第 i 天，最多 k 次交易，当前是否持股的最大收益


## 四、典型题型与模板

### 回溯经典题型：
1. **组合总和** - LeetCode 39 / 40
2. **N 皇后** - LeetCode 51
3. **电话号码的字母组合** - LeetCode 17
4. **子集** - LeetCode 78 / 子集 II（带重复） - LeetCode 90
5. **单词搜索** - LeetCode 79

### 回溯技巧：
- **剪枝**：排序后 `if (i > start && nums[i] == nums[i-1]) continue;`
- **使用 visited[]**：用于排列问题去重
- **在递归中传 start 指针**：用于组合类避免重复

### 动态规划经典题型：
1. **爬楼梯** - LeetCode 70（基础 DP）
2. **打家劫舍系列** - LeetCode 198 / 213 / 337（树形DP）
3. **最长递增子序列** - LeetCode 300
4. **0/1 背包问题** - 背包九讲经典
5. **编辑距离** - LeetCode 72（二维 DP）
6. **正则匹配** - LeetCode 10（Hard）
7. **旅行商问题（状态压缩）** - LeetCode 847 / 943 / 864

### DP 技巧：
- **滚动数组优化空间**
- **从后向前遍历避免重复覆盖**（如背包）
- **状态压缩**：位运算 `mask` 结合 `dp[mask][i]`
- **记忆化搜索 vs 递推 DP**：两种写法灵活切换


## 五、打怪升级：状态压缩 DP 实战模板

题型特征：
- 通常是完成一组任务的最短时间、最低代价或最大收益。
- 每个任务之间可能有转移代价或依赖关系。
- 任务完成情况可用一个整数的二进制（bitmask）来表示。


# 动态规划与回溯中等难度题目总结

## 🔎 一、动态规划（中等难度题目）

### 1. **爬楼梯（LeetCode 70）**
   - **题目简介**：假设你正在爬楼梯，每次可以爬 1 步或 2 步。求爬到顶部的不同方式。
   - **解题思路**：
     - 使用一维数组 `dp[i]` 表示爬到第 `i` 步的方法数。
     - 状态转移：`dp[i] = dp[i-1] + dp[i-2]`。
     - 边界条件：`dp[0] = 1`，`dp[1] = 1`。

### 2. **打家劫舍（LeetCode 198）**
   - **题目简介**：你是一个小偷，每次只能偷相邻的一个房子，计算你能偷到的最高金额。
   - **解题思路**：
     - `dp[i]` 表示偷到第 `i` 个房子的最大收益。
     - 状态转移：`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。
     - 边界条件：`dp[0] = nums[0]`，`dp[1] = max(nums[0], nums[1])`。

### 3. **最长递增子序列（LeetCode 300）**
   - **题目简介**：给定一个无序整数数组，找出其中最长递增子序列的长度。
   - **解题思路**：
     - 使用 `dp[i]` 表示以第 `i` 个元素结尾的最长递增子序列的长度。
     - 状态转移：`dp[i] = max(dp[i], dp[j] + 1)`，其中 `j < i` 且 `nums[j] < nums[i]`。
     - 时间复杂度为 O(n^2)。

### 4. **0/1 背包问题（LeetCode 416）**
   - **题目简介**：给定一个背包容量和一组物品，每个物品有重量和价值，求是否能恰好装满背包。
   - **解题思路**：
     - 定义 `dp[i]` 为容量为 `i` 时背包可以达到的最大价值。
     - 状态转移：`dp[i] = max(dp[i], dp[i-weight[j]] + value[j])`，从后往前遍历。
     - 时间复杂度为 O(n * W)，其中 `n` 为物品数，`W` 为背包容量。


## 🔎 二、回溯（中等难度题目）

### 1. **N 皇后问题（LeetCode 51）**
   - **题目简介**：在一个 `n x n` 的棋盘上放置 `n` 个皇后，使得它们不能相互攻击，返回所有合法的放置方式。
   - **解题思路**：
     - 使用回溯法枚举所有可能的放置方式。
     - 对每个行、列、对角线进行约束，确保没有皇后相互攻击。
     - 使用 `visited` 数组进行列和对角线的限制。

### 2. **组合总和（LeetCode 39）**
   - **题目简介**：给定一个候选数组 `candidates` 和目标值 `target`，找出所有可以使数字和为 `target` 的组合。
   - **解题思路**：
     - 使用回溯法搜索所有的组合。
     - 对候选数组进行排序，保证从小到大的选择。
     - 用递归 + 剪枝优化搜索。

### 3. **电话号码的字母组合（LeetCode 17）**
   - **题目简介**：给定一个仅包含数字 2-9 的字符串，返回所有可能的字母组合。
   - **解题思路**：
     - 使用回溯法递归生成每个数字对应的字母组合。
     - 每次选择一个数字的对应字母集，递归进入下一位。

### 4. **子集 II（LeetCode 90）**
   - **题目简介**：给定一个可能包含重复元素的整数数组 `nums`，返回该数组的所有子集。
   - **解题思路**：
     - 使用回溯法搜索所有子集。
     - 排序 `nums` 数组来帮助剪枝，避免生成重复的子集。
     - 每次选择一个数，递归生成子集。


## 🧩 三、总结与技巧

- **动态规划技巧**：
  - **空间优化**：使用滚动数组来优化空间复杂度。
  - **反向遍历**：如背包问题，从后往前遍历可以避免覆盖前面状态。
  - **状态压缩**：使用位运算和位掩码表示状态，减少空间复杂度。

- **回溯技巧**：
  - **剪枝**：通过排序和判断相邻元素相等，避免生成重复解。
  - **路径选择**：回溯时需要保证当前路径合法，递归前做选择，递归后撤销选择。

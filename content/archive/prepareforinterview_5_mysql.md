+++
title = "5天八股"
date = 2025-04-29T08:57:36+08:00
draft = false
description = ""
subtitle = "存储篇之Mysql"
header_img = ""
short = false
toc = true
tags = []
categories = ["计算机"]
series = ["面试"]
comment = false
summary = ""
+++

> 费曼学习法：学习->教学->纠错学习->简化教学


# 1. MySQL 基础

# 2. 索引与优化

# 3. 事务与隔离级别

# 4.锁
## 1. 分类
| 分类方式 | 锁类型 | 说明 |
|:---|:---|:---|
| 按操作对象粒度 | 表级锁 | 锁整张表，MyISAM默认。适合读多写少。 |
|  | 行级锁 | 锁定单行，InnoDB支持。高并发首选。 |
| 按锁行为 | 共享锁 (S Lock) | 读锁，多个事务可同时持有，阻塞写。 |
|  | 排他锁 (X Lock) | 写锁，独占资源，阻塞其他读写。 |
| 按加锁方式 | 自动加锁 | InnoDB根据SQL语义自动加锁。 |
|  | 显式加锁 | 使用 `SELECT ... FOR UPDATE`，`LOCK TABLES` 等。 |


## 2. 行锁分析

### 2.1 Record Lock（记录锁）
- 精确锁定某条已有记录。
- 精确匹配主键或唯一索引。

### 2.2 Gap Lock（间隙锁）
- 锁定两个记录之间的区间，不包含已有记录。
- 防止其他事务在区间内插入新记录，解决幻读问题。
- 范围查询+FOR UPDATE可能触发。

### 2.3 Next-Key Lock（临键锁）
- 结合Record Lock和Gap Lock：锁定记录及其前后间隙。
- 在RR隔离级别下默认开启，用于彻底防止幻读。
- InnoDB 8.0后在无冲突时可降级为Record Lock或Gap Lock，减少锁冲突。


## 3. 意向锁 (Intent Lock) 解析

- 意向锁是表级锁，标记事务意图，提升加锁冲突检测效率。
- IS（意向共享锁）：表示即将加共享行锁。
- IX（意向排他锁）：表示即将加排他行锁。
- 意向锁和行锁并不互斥，不会导致额外的锁等待，只是加速表锁检查。


## 4. 加锁方式理解

### 4.1 显式加锁SQL

- `SELECT ... FOR UPDATE`
  - 加排他锁，阻塞其他事务修改或加锁该行。
  - 适合读后即更新的场景，保证读-改-写一致性。

- `SELECT ... LOCK IN SHARE MODE`
  - 加共享锁，允许其他事务读，但阻止写。
  - 适合查询后验证但无需立即修改的场景。


### 4.2 何时可能锁表？

- 查询条件无索引或未使用索引导致全表扫描。
- 范围查询未走有效索引，锁范围扩大，导致临时表锁定。
- 外键约束检查导致间接表锁。
- 手动使用LOCK TABLES命令锁表。
- 并发DDL（表结构变更）未开启Online DDL功能时，普通DDL操作会锁表。

### 4.3 保证行锁效率的策略

- 合理设计索引，保证查询条件能命中索引。
- 尽量通过主键或唯一索引定位记录，避免全表锁或范围锁。
- 控制范围查询粒度，减少锁定记录数目。
- 缩短事务执行时间，快速提交，释放锁资源。

### 4.4 Online DDL是否锁表？

- MySQL 5.6及以上支持Online DDL：
  - 大多数索引变更操作可以边读写边修改，无需全表锁。
  - 但特定操作（如更改主键、添加全文索引）仍可能需要较大锁粒度或短暂元数据锁（MDL Lock）。
- 实际上线要关注DDL是否 truly online，可以通过 `ALGORITHM=INPLACE` 和 `LOCK=NONE` 选项强制要求。

## 5. 乐观锁与悲观锁深度区分

| 项目 | 乐观锁 | 悲观锁 |
|:---|:---|:---|
| 原理 | 基于版本控制或比较机制避免冲突 | 基于加锁阻止并发冲突 |
| 适用场景 | 高并发，冲突概率低 | 强一致性要求，高冲突场景 |

## 6. 死锁机制与优化
### 6.1 死锁成因

- 不同事务以不同顺序持有锁资源，互相等待。
- 大范围范围查询容易引起Next-Key锁竞争死锁。

### 6.2 死锁排查命令
```sql
SHOW ENGINE INNODB STATUS\G
```
- 查看当前死锁信息，定位涉及的事务和SQL。

### 6.3 死锁优化策略

- 统一事务访问资源顺序。
- 控制事务粒度，减少范围锁、减少锁等待。
- 提前检测冲突（应用层重试机制）。


---

## 7. 锁的总结

| 问题                           | 要点                                    |
|:-----------------------------|:--------------------------------------|
| 什么情况下InnoDB会锁表？              | 未命中索引、DDL操作、全表扫描、外键检查、行锁扩大。           |
| Next-Key Lock和Gap Lock的本质区别？ | Next-Key锁住记录及前后间隙，Gap Lock只锁区间，不含记录。  |
| SELECT FOR UPDATE为什么要求索引？    | 未命中索引则锁全表或大范围，影响并发性能。                 |
| Online DDL一定不会锁表吗？           | 不是，有些DDL操作仍需要锁表，需查看实际DDL语义。           |
| 如何排查死锁？                      | SHOW ENGINE INNODB STATUS，分析等待链与冲突资源。 |
# 5. MySQL 日志

# 6. 主从复制与高可用

# 7. 常见面试问题

# 8. MySQL 性能优化

# 9. 常见面试问题

1. 数据库三范式
2. 分别说一下范式和反范式的优缺点
3. Mysql 数据库索引。B+ 树和 B 树的区别
4. 为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）
5. 聚簇索引和非聚簇索引
6. 前缀索引和覆盖索引
7. 介绍一下数据库的事务
8. Mysql 有哪些隔离级别
9. Mysql 什么情况会造成脏读、可重复度、幻读？如何解决
10. Mysql 在可重复度的隔离级别下会不会有幻读的情况，为什么？
11. Mysql 事务是如何实现的
12. Binlog 和 Redo log 的区别是什么，分别是什么用？
13. 谈一谈 MVCC 多版本并发控制
14. Innodb 和 MyISAM 的区别是什么
15. Innodb 的默认加锁方式是什么，是怎么实现的
16. 如何高效处理大库 DDL
17. Mysql 索引重建
18. 对于多列索引，哪些情况下能用到索引，哪些情况用不到索引
19. 为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？
20. 共享锁和排他锁的使用场景，
21. 关系型数据库和非关系数据库的优缺点
22. Mysql 什么情况会造成慢查，如何查看慢查询
23. 如何处理慢查询，你一般是怎么处理慢查询的
24. Mysql 中 varchar 和 char 的区别
25. 数据库外键的优缺点
26. 有没有使用过数据库的视图
27. Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？
28. Mysql 有哪些数据类型，使用的时候有没有什么注意点
29. Mysql 集群有哪几种方式，分别适用于什么场景
30. Mysql 主从模式如何保证主从强一致性
31. Mysql 集群如何保证主从可用性
32. Mysql 读写分离有哪些解决办法





+++
title = "5天八股"
date = 2025-04-29T08:57:36+08:00
draft = false
description = ""
subtitle = "存储篇之Mysql"
header_img = ""
short = false
toc = true
tags = []
categories = ["计算机"]
series = ["面试"]
comment = false
summary = ""
+++

> 费曼学习法：学习->教学->纠错学习->简化教学


# 1. 执行流程
## 小目录

- 1. SQL生命周期概览
- 2. 解析阶段（Parse）
- 3. 查询重写阶段（Rewrite）
- 4. 查询优化阶段（Optimize）
- 5. 执行阶段（Execute）
- 6. 存储引擎层操作（Storage Engine）
- 7. 总结与高级扩展

---

## 1. SQL生命周期概览

> 一条SQL从客户端提交到最终执行完毕，MySQL内部经历以下关键步骤：

```mermaid
flowchart LR
A[客户端发送SQL] --> B[连接管理与权限校验]
B --> C[SQL解析]
C --> D[查询重写]
D --> E[查询优化器选择执行计划]
E --> F[执行器逐步执行]
F --> G[调用存储引擎读写数据]
G --> H[返回结果给客户端]
```

✅ 这条链路任何一个环节出问题都会导致SQL性能差异或异常。

## 2. 解析阶段（Parse）

### 2.1 词法/语法分析

- 词法分析（Lexer）：将SQL语句切分成关键字、表名、字段名等token。
- 语法分析（Parser）：根据SQL语法规则，生成**抽象语法树（AST，Abstract Syntax Tree）**。

✅ 报语法错误（比如漏写WHERE）就是在这个阶段发生。

### 2.2 权限验证

- 检查用户是否有对相关表、字段、操作类型（SELECT/INSERT/UPDATE等）的权限。

## 3. 查询重写阶段（Rewrite）

### 3.1 MySQL内置重写逻辑

- 将某些子查询转换为JOIN（半连接 Semi-Join优化）。
- 将`WHERE a=1 AND a=2`简化。
- 物化（Materialization）：将子查询先执行成临时表。

✅ 重写是为了让优化器更容易生成高效的执行计划。

### 3.2 应用层显式提示（Hint）

- FORCE INDEX、USE INDEX等也是一种"人为参与重写"，告诉优化器倾向选择某索引路径。

## 4. 查询优化阶段（Optimize）

### 4.1 逻辑优化

- 选择最佳JOIN顺序（基于成本估算）。
- 选择最优的索引路径（可能涉及ICP、索引覆盖等）。
- 简化表达式（如WHERE条件提前判断）

### 4.2 物理优化

- 确定访问方法（全表扫描、索引扫描、范围扫描、唯一索引查找）。
- 选择排序方式（索引排序或filesort）。
- 确定是否需要临时表（如GROUP BY大数据时）。

✅ 查询优化器最终生成**执行计划（Execution Plan）**，用于后续执行阶段。

## 5. 执行阶段（Execute）

### 5.1 执行器（Executor）工作流程

- 根据执行计划，按照指定顺序去访问表/索引。
- 每访问一行，进行WHERE条件过滤、GROUP BY聚合、ORDER BY排序等。
- 最终生成结果集，返回客户端或写入临时表等待后续处理。

### 5.2 Buffer Pool与预读优化

- 读页时优先查找Buffer Pool缓存。
- 触发顺序预读、随机预读机制减少磁盘IO。

## 6. 存储引擎层操作（Storage Engine）

### 6.1 读流程

- 根据索引（聚簇索引/二级索引）定位页（Page）。
- 加锁（行锁、间隙锁等）保障事务一致性。
- 应用MVCC（多版本并发控制）返回符合版本的数据。

### 6.2 写流程

- 修改内存中的页数据（Dirty Page）。
- 写入Redo Log（WAL，Write Ahead Log）保证持久性。
- 定时或主动刷脏页到磁盘（Flush Dirty Page）。

✅ 这一层极大影响事务隔离性、写放大、磁盘负载等。

## 7. 总结与高级扩展

### 总体回顾

| 阶段 | 关键点 |
|:---|:---|
| 解析（Parse） | 生成AST，发现语法错误 |
| 重写（Rewrite） | 子查询优化、显式Hint使用 |
| 优化（Optimize） | 生成最优访问路径与执行计划 |
| 执行（Execute） | 根据执行计划调度读写、应用WHERE/ORDER BY等 |
| 存储引擎（Storage） | 数据读写、MVCC、Redo/Undo机制 |

### 延伸思考

- 为什么有时候MySQL执行计划选错索引？（成本估算不准，统计信息过期）
- 为什么临时表影响性能？（临时表通常存在内存不足时落盘，IO慢）
- SQL性能问题应该在哪个阶段定位？（Parse错基本能看，Optimize错需EXPLAIN分析）


# 2. 索引与优化(ICP/索引覆盖/回表)


## 小目录

- 1. 回表机制（Back to Primary Lookup）
- 2. 覆盖索引（Covering Index）
- 3. 索引下推（Index Condition Pushdown, ICP）
- 4. 三者关系理解与配合优化
- 5. 执行计划（EXPLAIN）辨别技巧

## 1. 回表机制（Back to Primary Lookup）

### 原理
- 二级索引叶子节点只存储索引列+主键值。
- 查询需要其他字段时，需要通过主键去聚簇索引再次读取完整行数据。

### 问题
- 二级索引扫描时，回表带来大量**随机IO**，性能下降。

### 典型场景
```sql
SELECT * FROM user WHERE name = 'Tom';
```
（如果只有name的索引，需要根据name找到主键，再回表）

## 2. 覆盖索引（Covering Index）

### 原理
- 如果查询需要的所有列，**都在索引中能找到**，则直接在索引层返回结果，无需回表。

### 好处
- 避免回表随机IO，大幅提升查询性能。

### 典型场景
```sql
SELECT name FROM user WHERE name LIKE 'Tom%';
```
（只查name字段，直接覆盖在name索引上完成，无需回表）

### 如何设计覆盖索引
- 查询常用字段单独建联合索引，或者调整索引顺序。
- 查询列顺序无所谓，只要索引包含即可。

## 3. 索引下推（Index Condition Pushdown, ICP）

### 原理
- 让**部分WHERE条件**提前在索引叶子节点上判断，减少无效回表。

### 触发条件
| 条件 | 是否可ICP |
|:---|:---|
| 单列索引精准查找 | 不需要 |
| 单列索引范围查找 | 可以使用 |
| 联合索引前缀精准匹配+后缀过滤 | 不需要 |
| 联合索引前缀范围匹配+后缀过滤 | 可以使用 |

### 典型场景
```sql
SELECT * FROM user WHERE name LIKE 'Tom%' AND age = 30;
```
- `name`是前缀范围匹配，不能继续索引定位；
- `age`可以在索引叶子节点提前做过滤，减少回表。

### 检查是否启用ICP
```sql
EXPLAIN SELECT ...
```
- 看Extra字段是否出现 `Using index condition`

## 4. 三者关系理解与配合优化

| 特性 | 回表机制 | 覆盖索引 | 索引下推ICP |
|:---|:---|:---|:---|
| 目的 | 完整返回需要的数据行 | 避免回表 | 减少回表次数 |
| 是否需要回表 | 是 | 否 | 有可能（更少） |
| 最佳应用场景 | 查询所有字段 | 查询部分字段 | 联合索引+范围查询+后缀列过滤 |
| 典型优化方式 | 建立合理的联合索引 | 让查询字段落在索引内 | 让过滤条件提前下推到索引层 |

✅ 在查询设计时，合理利用**覆盖索引+索引下推**，可以极大提升大表扫描性能。

## 5. 执行计划（EXPLAIN）辨别技巧

| Extra字段 | 含义 |
|:---|:---|
| Using where | 需要在Server层进行WHERE过滤（未用ICP） |
| Using index condition | 触发了ICP，在存储引擎层过滤部分记录 |
| Using index | 覆盖索引，无需回表 |
| Using filesort | 可能存在额外的排序操作，需警惕性能问题 |


## 最后一句话总结

> **索引优化的核心目标是：尽量减少回表次数，能用索引直接返回就用覆盖索引，范围查询时配合索引下推过滤，做到真正利用索引提升IO效率与查询速度。**

# 3. 事务与隔离级别

## 一、事务核心概念：ACID 原则

| 属性 | 说明 | InnoDB 实现方式 |
|:--|:--|:--|
| 原子性 (Atomicity) | 事务中的所有操作要么全部执行，要么全部不执行 | Undo Log 回滚机制 |
| 一致性 (Consistency) | 数据必须从一个一致性状态转换为另一个一致性状态 | 外键/约束/触发器+事务特性维护 |
| 隔离性 (Isolation) | 并发事务之间互不干扰 | 锁机制 + MVCC + 隔离级别控制 |
| 持久性 (Durability) | 一旦事务提交，其修改是永久性的 | Redo Log + Binlog + Page Flush |

## 二、事务隔离级别详解（标准 vs InnoDB）

### 2.1 四种隔离级别（SQL标准定义）

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|:---|:---|:---|:---|
| Read Uncommitted | ✅ | ✅ | ✅ |
| Read Committed | ❌ | ✅ | ✅ |
| Repeatable Read（默认） | ❌ | ❌ | ✅（InnoDB已解决） |
| Serializable | ❌ | ❌ | ❌ |

### 2.2 InnoDB下各隔离级别的实际行为

- **Read Uncommitted**：
  - 所有操作都读最新数据（包括其他事务未提交）。
  - 实际上很少使用，几乎不隔离。

- **Read Committed**：
  - 每次读取都看到已提交版本（Oracle风格）。
  - 会产生不可重复读，但避免了脏读。

- **Repeatable Read（默认）**：
  - 同一事务内多次读取相同记录，结果一致（读取事务开始时的快照）。
  - InnoDB通过 MVCC + 间隙锁 完美解决幻读。

- **Serializable**：
  - 所有读都变成加锁的读（隐式 FOR UPDATE）。
  - 并发性能差，事务串行执行，几乎不用。

## 三、MVCC 实现原理（核心）

### 3.1 MVCC 的目标

- 实现 **非阻塞读（Consistent Read）**，提高并发性能。
- 在不加锁的情况下，提供事务一致性视图。

### 3.2 关键组件

| 组件 | 功能 |
|:--|:--|
| Undo Log | 保存数据的旧版本，实现回滚和一致性读 |
| ReadView | 事务读取时创建的快照视图，定义当前可见版本范围 |
| trx_id | 每个事务启动时分配的唯一递增ID，用于判断版本可见性 |

### 3.3 MVCC 工作流程

- InnoDB使用两个隐藏列维护版本信息：`trx_id`, `roll_pointer`。
- 读操作（非锁定）：根据 ReadView 判断记录版本是否可见。
- 写操作：分配新的 `trx_id`，并写入 Undo Log 保存旧版本。
## 四、幻读问题处理机制

### 4.1 幻读定义
- 在同一个事务中，先执行某条件查询，接着执行相同条件的插入，再次查询时多出数据。
- 通常出现在 **范围查询 + 插入** 的组合。

### 4.2 解决方式对比

| 方法 | 能否防止幻读 | 开销 |
|:--|:--|:--|
| Serializable 隔离级别 | ✅ | 高，强制加表锁或范围锁 |
| Repeatable Read + Next-Key Lock（InnoDB） | ✅ | 中，锁定记录及其间隙，防止插入 |
| Read Committed | ❌ | 无法防止幻读，需要额外手段 |

## 五、ReadView 判定规则（是否可见）

InnoDB 使用以下条件判断某行版本是否对当前事务可见：

```text
版本可见的条件：
1. 数据版本的 trx_id < ReadView.min_trx_id（已提交） ✅
2. 数据版本的 trx_id == 当前事务ID（自身创建） ✅
3. 数据版本的 trx_id ∈ ReadView.active_trx_ids（未提交） ❌
```

## 六、事务隔离相关面试常见问题

| 问题 | 要点回答 |
|:---|:---|
| InnoDB 是如何实现事务隔离的？ | MVCC+锁机制。RR隔离级别配合Next-Key Lock解决幻读。 |
| 什么是 ReadView？ | 一致性读视图，用于判断记录版本是否可见，是MVCC的核心。 |
| Repeatable Read 如何避免幻读？ | InnoDB通过Next-Key Lock锁定间隙防止插入实现。 |
| Serializable 隔离级别的实现方式？ | 强制读加锁，事务串行执行，极大降低并发。 |
| Undo Log 与 Redo Log 有何区别？ | Undo用于回滚与一致性读，Redo用于持久性保证与崩溃恢复。 |
| MySQL 默认隔离级别为什么选RR？ | 能避免幻读同时性能优于Serializable，是兼顾一致性与性能的折中。 |

# 4.锁
## 1. 分类
| 分类方式 | 锁类型 | 说明 |
|:---|:---|:---|
| 按操作对象粒度 | 表级锁 | 锁整张表，MyISAM默认。适合读多写少。 |
|  | 行级锁 | 锁定单行，InnoDB支持。高并发首选。 |
| 按锁行为 | 共享锁 (S Lock) | 读锁，多个事务可同时持有，阻塞写。 |
|  | 排他锁 (X Lock) | 写锁，独占资源，阻塞其他读写。 |
| 按加锁方式 | 自动加锁 | InnoDB根据SQL语义自动加锁。 |
|  | 显式加锁 | 使用 `SELECT ... FOR UPDATE`，`LOCK TABLES` 等。 |


## 2. 行锁分析

### 2.1 Record Lock（行所）
- 精确锁定某条已有记录。
- 精确匹配主键或唯一索引。

### 2.2 Gap Lock（间隙锁）
- 锁定两个记录之间的区间，不包含已有记录。
- 防止其他事务在区间内插入新记录，解决幻读问题。
- 范围查询+FOR UPDATE可能触发。

### 2.3 Next-Key Lock（临键锁）
- 结合Record Lock和Gap Lock：锁定记录及其前后间隙。
- 在RR隔离级别下默认开启，用于彻底防止幻读。
- InnoDB 8.0后在无冲突时可降级为Record Lock或Gap Lock，减少锁冲突。


## 3. 意向锁 (Intent Lock) 解析

- 意向锁是表级锁，标记事务意图，提升加锁冲突检测效率。
- IS（意向共享锁）：表示即将加共享行锁。
- IX（意向排他锁）：表示即将加排他行锁。
- 意向锁和行锁并不互斥，不会导致额外的锁等待，只是加速表锁检查。


## 4. 加锁方式理解

### 4.1 显式加锁SQL

- `SELECT ... FOR UPDATE`
  - 加排他锁，阻塞其他事务修改或加锁该行。
  - 适合读后即更新的场景，保证读-改-写一致性。

- `SELECT ... LOCK IN SHARE MODE`
  - 加共享锁，允许其他事务读，但阻止写。
  - 适合查询后验证但无需立即修改的场景。

### 4.2 何时可能锁表？

- 查询条件无索引或未使用索引导致全表扫描。
- 范围查询未走有效索引，锁范围扩大，导致临时表锁定。
- 外键约束检查导致间接表锁。
- 手动使用LOCK TABLES命令锁表。
- 并发DDL（表结构变更）未开启Online DDL功能时，普通DDL操作会锁表。

### 4.3 保证行锁效率的策略

- 合理设计索引，保证查询条件能命中索引。
- 尽量通过主键或唯一索引定位记录，避免全表锁或范围锁。
- 控制范围查询粒度，减少锁定记录数目。
- 缩短事务执行时间，快速提交，释放锁资源。

### 4.4 Online DDL是否锁表？

- MySQL 5.6及以上支持Online DDL：
  - 大多数索引变更操作可以边读写边修改，无需全表锁。
  - 但特定操作（如更改主键、添加全文索引）仍可能需要较大锁粒度或短暂元数据锁（MDL Lock）。
- 实际上线要关注DDL是否 truly online，可以通过 `ALGORITHM=INPLACE` 和 `LOCK=NONE` 选项强制要求。

## 5. 乐观锁与悲观锁深度区分

| 项目 | 乐观锁 | 悲观锁 |
|:---|:---|:---|
| 原理 | 基于版本控制或比较机制避免冲突 | 基于加锁阻止并发冲突 |
| 适用场景 | 高并发，冲突概率低 | 强一致性要求，高冲突场景 |

## 6. 死锁机制与优化
### 6.1 死锁成因

- 不同事务以不同顺序持有锁资源，互相等待。
- 大范围范围查询容易引起Next-Key锁竞争死锁。

### 6.2 死锁排查命令
```sql
SHOW ENGINE INNODB STATUS\G
```
- 查看当前死锁信息，定位涉及的事务和SQL。

### 6.3 死锁优化策略

- 统一事务访问资源顺序。
- 控制事务粒度，减少范围锁、减少锁等待。
- 提前检测冲突（应用层重试机制）。

## 7. 锁的总结

| 问题                           | 要点                                    |
|:-----------------------------|:--------------------------------------|
| 什么情况下InnoDB会锁表？              | 未命中索引、DDL操作、全表扫描、外键检查、行锁扩大。           |
| Next-Key Lock和Gap Lock的本质区别？ | Next-Key锁住记录及前后间隙，Gap Lock只锁区间，不含记录。  |
| SELECT FOR UPDATE为什么要求索引？    | 未命中索引则锁全表或大范围，影响并发性能。                 |
| Online DDL一定不会锁表吗？           | 不是，有些DDL操作仍需要锁表，需查看实际DDL语义。           |
| 如何排查死锁？                      | SHOW ENGINE INNODB STATUS，分析等待链与冲突资源。 |
# 5. MySQL 日志

# 6. 主从复制与高可用

# 7. 常见面试问题

# 8. MySQL 性能优化

# 9. 常见面试问题

1. 数据库三范式
2. 分别说一下范式和反范式的优缺点
3. Mysql 数据库索引。B+ 树和 B 树的区别
4. 为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）
5. 聚簇索引和非聚簇索引
6. 前缀索引和覆盖索引
~~7. 介绍一下数据库的事务~~
8. Mysql 有哪些隔离级别
9. Mysql 什么情况会造成脏读、可重复度、幻读？如何解决
10. Mysql 在可重复度的隔离级别下会不会有幻读的情况，为什么？
11. Mysql 事务是如何实现的
12. Binlog 和 Redo log 的区别是什么，分别是什么用？
13. 谈一谈 MVCC 多版本并发控制
14. Innodb 和 MyISAM 的区别是什么
15. Innodb 的默认加锁方式是什么，是怎么实现的
16. 如何高效处理大库 DDL
17. Mysql 索引重建
18. 对于多列索引，哪些情况下能用到索引，哪些情况用不到索引
19. 为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？
20. 共享锁和排他锁的使用场景，
21. 关系型数据库和非关系数据库的优缺点
22. Mysql 什么情况会造成慢查，如何查看慢查询
23. 如何处理慢查询，你一般是怎么处理慢查询的
24. Mysql 中 varchar 和 char 的区别
25. 数据库外键的优缺点
26. 有没有使用过数据库的视图
27. Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？
28. Mysql 有哪些数据类型，使用的时候有没有什么注意点
29. Mysql 集群有哪几种方式，分别适用于什么场景
30. Mysql 主从模式如何保证主从强一致性
31. Mysql 集群如何保证主从可用性
32. Mysql 读写分离有哪些解决办法





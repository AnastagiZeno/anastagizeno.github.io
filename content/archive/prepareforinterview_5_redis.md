+++
title = "5天八股"
date = 2025-04-29T20:23:03+08:00
draft = false
description = ""
subtitle = "之Redis篇"
header_img = ""
short = false
toc = true
tags = []
categories = []
series = []
comment = false
summary = ""
+++

# Redis 核心数据结构与高性能原理

## 一、Redis 为什么快？

- **单线程模型**：避免多线程加锁和上下文切换，基于事件循环 + epoll。
- **纯内存存储**：数据全部在内存中，访问速度快。
- **高效的数据结构**：精心设计的结构匹配不同使用场景。
- **命令执行快**：大多数操作时间复杂度为 O(1) 或 O(logN)。

> 阿里的Tair对在开源redis上做了优化，主要采用了
> `多线程I/O + Worker模型`，多核下读写性能可达redis的3倍。 持久化方面也做了很多优化和扩展。
> 提供丰富的运维工具，top热key，大key监控非常便捷。HA、水平扩展等。

## 二、常见数据结构与底层实现

| 数据类型 | 应用场景 | 底层实现 |
|----------|----------|----------|
| String   | 计数器、Token、锁 | SDS（简单动态字符串） |
| List     | 消息队列、时间轴 | quicklist（ziplist + 链表） |
| Hash     | 用户信息、配置表 | ziplist / hashtable |
| Set      | 标签、去重集合 | intset / hashtable |
| SortedSet| 排行榜、延时队列 | skiplist + hashtable |
| Bitmap   | 用户打卡、签到 | 位数组 |
| HyperLogLog | UV 统计 | 概率数据结构（误差约 0.81%） |
| Geo      | LBS 应用 | SortedSet 实现 |
| Stream   | 消息队列、日志系统 | 双端链表 + Radix Tree + listpack |

> 亲身经历的工作内容：
> 1. string - **计数器**：业务上各种疲劳度计数、库存扣减；**缓存**：不用说了各种配置缓存（当持久化库用的），请求缓存，耗时查询结果缓存。**锁**：worker并发控制，兑换/购买流程请求防重防连击上锁，并发回源数据db保护上锁。
> 2. list - **消息队列**：简易版的，后台多worker处理经验过期，主push到list，多个worker去pop消费。易于控制消费节奏，可以随时查看队列状态。没有mq那么重。**时间轴**兑换x天y次这种疲劳度用list做的
> 3. hash - **配置表**:也是配置，跟string一样，有些是string存的json，有些是直接用的hash。比较固定的配置就用string的json的，动态快速增长的就用hash了。
> 4. SortedSet - **延时队列、排行榜**：后台worker任务的时候，为了动态控制worker数量和做一个监控，自己实现了一个小的注册中心，用的就是sortedSet，value是机器IP，score是心跳时间戳，定期去删除过期的。
> 5. Bitmap - 没用过，不过有一阵防黑产的时候考虑过做一个布隆过滤器，但是后来没做。主要工作交给网关（霸下）+风控+业务限制了。

## 三、对象编码机制（redisObject）

| 数据结构 | 编码方式 | 触发条件 |
|----------|----------|----------|
| String   | int / embstr / raw | embstr：短字符串（<= 39 字节） |
| List     | ziplist / quicklist | 元素较少时使用 ziplist |
| Hash     | ziplist / hashtable | 字段少且短时使用 ziplist |
| Set      | intset / hashtable | 小整数集合用 intset |
| SortedSet| ziplist / skiplist | 数据量小时 ziplist |
| Stream   | listpack / radix tree | 高效压缩消息块存储 |

**5.0之后，ziplist开始被listpack逐渐取代**
## 四、内存优化机制

- **Jemalloc 内存分配器**：减少碎片，提高分配效率。
- **对象共享机制**：小整数值复用，节省内存。
- **惰性删除 + 定期删除**：处理过期键，减少阻塞。
- **压缩结构使用**：如 ziplist、intset 节省内存空间。

## 五、常见面试问题

1. **Redis 为什么是单线程还这么快？**  
   >因为 Redis 是纯内存操作 + 使用 epoll 实现的事件驱动模型，大多数命令是 O(1) 或 O(logN)，避免了多线程锁竞争和上下文切换。

2. **为什么 SortedSet 用 skiplist 而不是平衡树？**  
   >skiplist 插入/删除效率稳定（O(logN)），实现简单，支持范围查询更方便；相比平衡树更容易实现有序遍历。

3. **ziplist 和 hashtable 是如何切换的？**  
   >Hash 类型在字段数较少（默认 < 512）且字段和值较短（< 64字节）时使用 ziplist，否则切换为 hashtable。

4. **为什么 String 类型不直接用 char*，而用 SDS？**  
   >SDS 支持 O(1) 获取长度，自动扩容，避免缓冲区溢出，兼容二进制数据，解决 C 字符串的一些问题。

5. **quicklist 如何优化 List？与链表相比有什么优势？**  
   >quicklist 是 ziplist 与双向链表结合体，减少内存碎片和指针开销，提高 CPU 缓存命中率，同时保留链表快速插入删除特性。


# 自测
1. redis 的底层数据结构有哪些
2. redis 中的 SDS 和 C 语言中的字符串有什么区别，优点是什么 
3. redis 中的字典是如何实现的，如何解决冲突和扩容 
> 数据量少的时候使用的ziplist，节约空间，查询时间复杂度O(n)可接受, 量大的话就是用的哈希表了，value（也就是bucket）存储的是链表，处理哈希碰撞。
> 哈希冲突太多（实际的key多于bucket数量）的时候需要扩容，redis字典结构实际是有两个哈希表，一个是当前用的，另一个用于扩容，扩容是渐进式的，全部扩容完毕后，1和2对换一下就行了。
4. redis 的跳表的使用场景是什么，可以实现一下吗
> sortedSet使用跳表，用于高效的范围查询。实现的话就是多层数组（链表）来实现，底层全量，上层越往上越稀疏（跳跃）。
5. redis 缓存穿透，缓存击穿，缓存雪崩，热点数据集中失效 （常问） 
> 穿透：布隆过滤器，或者缓存一个空/假值，过期时间设小点。
> 击穿、雪崩：动态过期时间，热key哈希打散/或者热key常驻，配合本地缓存，回源数据时上锁。
6. redis 的淘汰策略，来写一下 LRU 吧 
> 主要基于LRU，标记。然后有惰性删除和后台线程定期扫描删除。
7. redis 的持久化方式，RDB 和 AOF 分别的使用场景 
> Redis 提供两种持久化方式：RDB 以快照形式周期性保存内存数据，适合冷备与快速恢复；AOF 则记录每条写命令，数据更完整，适合实时性高、要求高可用的场景。通常线上推荐 RDB + AOF 混合使用，兼顾性能和安全。
8. redis 如何处理事务 redis 为什么那么快？ 
9. redis 是单线程为什么还那么快？ 
> 单线程模型，配合epoll事件轮询，没有线程间切换和处理锁的开销，所以快。
> redis 6.0之后/或者基于开源redis的定制化优化版本，比如阿里的tair，为了提高多核的效率，在网络层加入了多线程多IO/多worker线程处理任务，提高并发处理效率
10. redis 的操作为什么是原子性的，如何保证原子性 
> redis单线程模型，单个命令都是原子操作。
> 事务、或者lua脚本也都是命令进入队列，redis执行的时候仍然是单线程顺序执行，不会被中断。虽然不支持回滚，算不上是真正的原子性，但却是不能被并发破坏。
11. redis 集群用过哪些方案，分别怎么做。讲一下一致性哈希 
12. redis 什么情况下会出现性能问题，有什么处理办法？ 有没有使用过 
> 我们用的tair，有个打分器，基本关注的就是：大key（要拆），热key（本地缓存，或拆），数据/访问倾斜（重新设计下key，争取打散，比如多个常驻key流量高，碰巧好几个都在一个分片上），慢查询：返回内容太多（这个基本没遇到过）
> 系统层面主要关注的就是：cpu（尖刺查问题，长时间太高了得升配），内存（必须预留足够的安全阈值，不然内存不足频繁淘汰扛不住的），网络吞吐、延迟（复制也受影响）。
13. redis 的分布式锁，有什么优缺点 说一下 
> 优点：快，简单，分布式
> 缺点：其实没遇到过缺点，硬说就是不可重入。再有就是复杂功能需要客户端自己实现比如自旋之类的。
14. redis 的内存模型 说一下 
15. redis 和 memcache 的区别
> 没用过memcache，不知道
16. 你用 redis 做过什么？（这里尽量不要讲只做过缓存，可以说一下队列，排行榜/计数器，发布/订阅） 
> 上面写了，锁，计数器，字典配置，延迟队列（排行榜），消息队列（list自己实现的用过，pub/sub也简单用过但当时不支持cluster）都用过了。
17. 你用过哪些非关系型数据库，都有什么特点，使用场景分别是什么（体现你技术广度的时刻到了，尽可能多说，但是不会的不要说，防止被问死） 
> redis, cassandra(pt时候记前端上报的用户行为日志), dynamodb（pt-dd时候记录数据源信息）, odps（amap时候做bi统计）, es（pt-lx时候记录用户行为数据并且做session结算）
18. Mongodb 相对于 Mysql 有哪些优势，底层索引使用的数据结构是什么，为什么要使用这个 Mongodb 中的分片是什么意思
> 精简版：非结构化，横向无限扩展，文档存储
> MongoDB 相比 MySQL 更适合非结构化、动态字段场景，支持横向分片扩展与文档模型；其索引底层基于 B+Tree，便于高性能范围查找；分片机制通过 mongos 路由请求、shard 存储数据，实现水平扩展能力，关键在于合理设计分片键。

# 复习中的疑问
1. redis的`List`为何不直接使用链表，却要把ziplist加入进去，ziplist本质是数组，插入删除是O(n)，同时redis的list也不支持按照索引获取数据（实际支持，但是不推荐用，因为链表O(n)）
> Redis没采用纯链表实现List，是因为链表占用内存高、CPU缓存不友好(因为链表是分散的，不像数组是连续开辟内存)。为了提高内存效率和访问性能，Redis 用 ziplist 存多个元素，再用链表连接多个 ziplist，这种结构称为 quicklist。它兼顾了插入删除效率与空间利用，是 List 的默认实现方式。
> 多说一点，5.0之后，Redis开始弃用ziplist改用listpack（再次优化后的ziplist）

2. 数据结构选型问题，关于跳表

>**sortedList 选择跳表+Hash作为底层数据结构，排序、范围查询主要依赖跳表，那么选择跳表不选择红黑树的原因是？**
>
>| 比较点       | 跳表（SkipList）                        | 红黑树（Red-Black Tree）               |
>|--------------|------------------------------------------|----------------------------------------|
>| 实现复杂度   | 低（无需旋转）                            | 高（插入/删除需维护颜色+旋转）         |
>| 插入/删除性能 | 平均 O(logN)，最坏 O(N)（概率很低）       | 始终 O(logN)，但旋转频繁               |
>| 范围查询     | 非常自然，顺序遍历链表即可                 | 需要中序遍历实现                        |
>| 顺序访问     | ✅ 更适合，天然链表结构                   | ❌ 无法直接按顺序遍历                   |
>| 空间消耗     | 略高（多层指针）                           | 略低                                   |
>| 使用稳定性   | 非常好，均衡性概率控制可调（p, maxLevel） | 旋转逻辑复杂，影响调试与维护           |

>**mysql索引使用B+树，可以用跳表替代吗?**
>
>| 比较点           | 跳表                               | B+ 树（MySQL 索引）                    |
>|------------------|------------------------------------|----------------------------------------|
>| 是否适合磁盘访问 | ❌ 不适合，跳跃节点不连续，随机 I/O 多 | ✅ 适合，页为单位组织数据，节点顺序紧凑 |
>| I/O 次数控制     | 差，访问多层级指针带来随机跳转       | 好，树高低、扇出大，访问次数少（logN）  |
>| 顺序扫描性能     | 差，链表节点分布分散                 | 非常高效，叶子节点双向链表             |
>| 写入放大         | 高，跳表节点变化频繁                 | 控制合理，InnoDB 有插入缓冲            |
>| 查询优化         | 缺少页级管理                         | 支持 Buffer Pool、预读、合并、redo 日志等 |
+++
title = "5天八股"
date = 2025-04-29T20:23:03+08:00
draft = false
description = ""
subtitle = "之Redis篇"
header_img = ""
short = false
toc = true
tags = []
categories = []
series = []
comment = false
summary = ""
+++

# Redis 核心数据结构与高性能原理

## 一、Redis 为什么快？

- **单线程模型**：避免多线程加锁和上下文切换，基于事件循环 + epoll。
- **纯内存存储**：数据全部在内存中，访问速度快。
- **高效的数据结构**：精心设计的结构匹配不同使用场景。
- **命令执行快**：大多数操作时间复杂度为 O(1) 或 O(logN)。

> 阿里的Tair对在开源redis上做了优化，主要采用了
> `多线程I/O + Worker模型`，多核下读写性能可达redis的3倍。 持久化方面也做了很多优化和扩展。
> 提供丰富的运维工具，top热key，大key监控非常便捷。HA、水平扩展等。

## 二、常见数据结构与底层实现

| 数据类型 | 应用场景 | 底层实现 |
|----------|----------|----------|
| String   | 计数器、Token、锁 | SDS（简单动态字符串） |
| List     | 消息队列、时间轴 | quicklist（ziplist + 链表） |
| Hash     | 用户信息、配置表 | ziplist / hashtable |
| Set      | 标签、去重集合 | intset / hashtable |
| SortedSet| 排行榜、延时队列 | skiplist + hashtable |
| Bitmap   | 用户打卡、签到 | 位数组 |
| HyperLogLog | UV 统计 | 概率数据结构（误差约 0.81%） |
| Geo      | LBS 应用 | SortedSet 实现 |
| Stream   | 消息队列、日志系统 | 双端链表 + Radix Tree + listpack |

> 亲身经历的工作内容：
> 1. string - **计数器**：业务上各种疲劳度计数、库存扣减；**缓存**：不用说了各种配置缓存（当持久化库用的），请求缓存，耗时查询结果缓存。**锁**：worker并发控制，兑换/购买流程请求防重防连击上锁，并发回源数据db保护上锁。
> 2. list - **消息队列**：简易版的，后台多worker处理经验过期，主push到list，多个worker去pop消费。易于控制消费节奏，可以随时查看队列状态。没有mq那么重。**时间轴**兑换x天y次这种疲劳度用list做的
> 3. hash - **配置表**:也是配置，跟string一样，有些是string存的json，有些是直接用的hash。比较固定的配置就用string的json的，动态快速增长的就用hash了。
> 4. SortedSet - **延时队列、排行榜**：后台worker任务的时候，为了动态控制worker数量和做一个监控，自己实现了一个小的注册中心，用的就是sortedSet，value是机器IP，score是心跳时间戳，定期去删除过期的。
> 5. Bitmap - 没用过，不过有一阵防黑产的时候考虑过做一个布隆过滤器，但是后来没做。主要工作交给网关（霸下）+风控+业务限制了。

## 三、对象编码机制（redisObject）

| 数据结构 | 编码方式 | 触发条件 |
|----------|----------|----------|
| String   | int / embstr / raw | embstr：短字符串（<= 39 字节） |
| List     | ziplist / quicklist | 元素较少时使用 ziplist |
| Hash     | ziplist / hashtable | 字段少且短时使用 ziplist |
| Set      | intset / hashtable | 小整数集合用 intset |
| SortedSet| ziplist / skiplist | 数据量小时 ziplist |
| Stream   | listpack / radix tree | 高效压缩消息块存储 |

**5.0之后，ziplist开始被listpack逐渐取代**
## 四、内存优化机制

- **Jemalloc 内存分配器**：减少碎片，提高分配效率。
- **对象共享机制**：小整数值复用，节省内存。
- **惰性删除 + 定期删除**：处理过期键，减少阻塞。
- **压缩结构使用**：如 ziplist、intset 节省内存空间。

## 五、常见面试问题

1. **Redis 为什么是单线程还这么快？**  
   >因为 Redis 是纯内存操作 + 使用 epoll 实现的事件驱动模型，大多数命令是 O(1) 或 O(logN)，避免了多线程锁竞争和上下文切换。

2. **为什么 SortedSet 用 skiplist 而不是平衡树？**  
   >skiplist 插入/删除效率稳定（O(logN)），实现简单，支持范围查询更方便；相比平衡树更容易实现有序遍历。

3. **ziplist 和 hashtable 是如何切换的？**  
   >Hash 类型在字段数较少（默认 < 512）且字段和值较短（< 64字节）时使用 ziplist，否则切换为 hashtable。

4. **为什么 String 类型不直接用 char*，而用 SDS？**  
   >SDS 支持 O(1) 获取长度，自动扩容，避免缓冲区溢出，兼容二进制数据，解决 C 字符串的一些问题。

5. **quicklist 如何优化 List？与链表相比有什么优势？**  
   >quicklist 是 ziplist 与双向链表结合体，减少内存碎片和指针开销，提高 CPU 缓存命中率，同时保留链表快速插入删除特性。


# 自测
1. redis 的底层数据结构有哪些
2. redis 中的 SDS 和 C 语言中的字符串有什么区别，优点是什么 
3. redis 中的字典是如何实现的，如何解决冲突和扩容 
4. redis 的跳表的使用场景是什么，可以实现一下吗 
5. redis 缓存穿透，缓存击穿，缓存雪崩，热点数据集中失效 （常问） 
6. redis 的淘汰策略，来写一下 LRU 吧 
7. redis 的持久化方式，RDB 和 AOF 分别的使用场景 
8. redis 如何处理事务 redis 为什么那么快？ 
9. redis 是单线程为什么还那么快？ 
10. redis 的操作为什么是原子性的，如何保证原子性 
11. redis 集群用过哪些方案，分别怎么做。讲一下一致性哈希 
12. redis 什么情况下会出现性能问题，有什么处理办法？ 有没有使用过 
13. redis 的分布式锁，有什么优缺点 说一下 
14. redis 的内存模型 说一下 
15. redis 和 memcache 的区别 
16. 你用 redis 做过什么？（这里尽量不要讲只做过缓存，可以说一下队列，排行榜/计数器，发布/订阅） 
17. 你用过哪些非关系型数据库，都有什么特点，使用场景分别是什么（体现你技术广度的时刻到了，尽可能多说，但是不会的不要说，防止被问死） 
18. Mongodb 相对于 Mysql 有哪些优势，底层索引使用的数据结构是什么，为什么要使用这个 Mongodb 中的分片是什么意思

# 复习中的疑问
1. redis的`List`为何不直接使用链表，却要把ziplist加入进去，ziplist本质是数组，插入删除是O(n)，同时redis的list也不支持按照索引获取数据（实际支持，但是不推荐用，因为链表O(n)）
> Redis没采用纯链表实现List，是因为链表占用内存高、CPU缓存不友好(因为链表是分散的，不像数组是连续开辟内存)。为了提高内存效率和访问性能，Redis 用 ziplist 存多个元素，再用链表连接多个 ziplist，这种结构称为 quicklist。它兼顾了插入删除效率与空间利用，是 List 的默认实现方式。
> 多说一点，5.0之后，Redis开始弃用ziplist改用listpack（再次优化后的ziplist）
2. 数据结构选型问题，关于跳表
**sortedList 选择跳表+Hash作为底层数据结构，排序、范围查询主要依赖跳表，那么选择跳表不选择红黑树的原因是？**
| 比较点       | 跳表（SkipList）                        | 红黑树（Red-Black Tree）               |
|--------------|------------------------------------------|----------------------------------------|
| 实现复杂度   | 低（无需旋转）                            | 高（插入/删除需维护颜色+旋转）         |
| 插入/删除性能 | 平均 O(logN)，最坏 O(N)（概率很低）       | 始终 O(logN)，但旋转频繁               |
| 范围查询     | 非常自然，顺序遍历链表即可                 | 需要中序遍历实现                        |
| 顺序访问     | ✅ 更适合，天然链表结构                   | ❌ 无法直接按顺序遍历                   |
| 空间消耗     | 略高（多层指针）                           | 略低                                   |
| 使用稳定性   | 非常好，均衡性概率控制可调（p, maxLevel） | 旋转逻辑复杂，影响调试与维护           |

**mysql索引使用B+树，可以用跳表替代吗？ **
| 比较点           | 跳表                               | B+ 树（MySQL 索引）                    |
|------------------|------------------------------------|----------------------------------------|
| 是否适合磁盘访问 | ❌ 不适合，跳跃节点不连续，随机 I/O 多 | ✅ 适合，页为单位组织数据，节点顺序紧凑 |
| I/O 次数控制     | 差，访问多层级指针带来随机跳转       | 好，树高低、扇出大，访问次数少（logN）  |
| 顺序扫描性能     | 差，链表节点分布分散                 | 非常高效，叶子节点双向链表             |
| 写入放大         | 高，跳表节点变化频繁                 | 控制合理，InnoDB 有插入缓冲            |
| 查询优化         | 缺少页级管理                         | 支持 Buffer Pool、预读、合并、redo 日志等 |
+++
title = "服务端面试之OS、Network篇"
date = 2025-05-01T17:03:45+08:00
draft = false
description = ""
subtitle = "之OS、Network篇"
header_img = "/image/2025/siegeofmalta.png"
short = false
toc = true
tags = []
categories = ["计算机"]
series = ["面试系列"]
comment = false
summary = ""
hidden = true
+++

# 加锁保护的是什么？变量？线程？内存？

## 1. 加锁本质是什么？锁保护的到底是啥？

> ✅ 锁本质上是对某段内存操作行为的互斥访问保证，
> 它保护的不是“线程”或“变量”，而是对**访问共享资源的执行路径的排他性控制**。

## 2. 锁从 OS 层面是如何实现的？

加锁通常依赖如下底层机制：

| 层级   | 技术/指令                                  |
|--------|---------------------------------------------|
| CPU    | `LOCK CMPXCHG`、`XCHG`、`MFENCE` 等原子指令 |
| 内核   | `futex`（Linux）、`WaitOnAddress`（Windows） |
| 用户态 | 自旋锁、自旋失败后调用系统调用阻塞线程     |

## 3. 加锁时到底发生了什么？

以 Python/Go 中的 `lock.acquire()` 为例：

### ① 尝试加锁（用户态快速路径）：
- 使用原子指令（如 CAS）尝试获取锁；
- 如果成功，直接进入临界区；

### ② 如果失败（锁已被占）：
- 进入内核态，调用 `futex` 等机制将当前线程挂起；
- 操作系统调度器会阻止该线程继续运行，直到锁被释放；

### ③ 临界区只允许一个线程运行：
- 在持锁期间，只有持有者可以访问共享内存；
- 写完共享数据，调用 `release()` 释放锁；

### ④ 锁释放后：
- 操作系统会唤醒阻塞的线程队列；
- 被唤醒线程继续尝试获取锁；

## 4. 常见误解澄清

### ❓“锁是不是保护变量？”
> ❌ 错。变量本身无法“被保护”。锁只保证访问该变量的执行路径互斥。

### ❓“线程会读不到变量吗？”
> ❌ 错。内存本身谁都能读。只是未持锁线程会被 OS 阻塞，**无法执行读写指令**。

## 5. 多语言加锁机制对比

| 语言       | 锁机制                    | 阻塞策略              |
|------------|---------------------------|------------------------|
| Go         | `sync.Mutex`              | 自旋 + futex           |
| Java       | `synchronized`, `ReentrantLock` | monitor + 自旋      |
| Python     | `threading.Lock()`        | GIL + POSIX lock       |
| C/C++      | `pthread_mutex_t`         | futex / syscall        |

## 6. 总结语

> 加锁不是为了阻止线程访问变量，而是通过原子指令和调度机制确保在任意时刻，只有一个线程能够完整地执行对共享内存的操作。
>
> 未持有锁的线程会被 OS 阻塞，从而防止并发冲突，确保程序的正确性和一致性。

# 内存屏障

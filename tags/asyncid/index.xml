<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Asyncid on az1453</title>
    <link>https://anastagizeno.github.io/tags/asyncid/</link>
    <description>Recent content in Asyncid on az1453</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © 2019, Bingxing Kang. All rights reserved.</copyright>
    <lastBuildDate>Mon, 24 Jun 2019 10:41:55 +0800</lastBuildDate>
    
	<atom:link href="https://anastagizeno.github.io/tags/asyncid/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Notes for Using Asyncio in Py3</title>
      <link>https://anastagizeno.github.io/post/2019/06/notes-for-using-asyncio-in-py3/</link>
      <pubDate>Mon, 24 Jun 2019 10:41:55 +0800</pubDate>
      
      <guid>https://anastagizeno.github.io/post/2019/06/notes-for-using-asyncio-in-py3/</guid>
      <description>&lt;p&gt;Async Generators: yield Inside async def Functions
Async generators answer the question, “What happens if you use yield inside a native async def coroutine function?” This concept might be confusing if you have some experience with using generators as if they were coroutines, such as with the Twisted framework, or the Tornado framework, or even with yield from in Python 3.4’s asyncio.&lt;/p&gt;

&lt;p&gt;Therefore, before we continue in this section, it is best if you can convince yourself that:&lt;/p&gt;

&lt;p&gt;Coroutines and generators are completely different concepts.&lt;/p&gt;

&lt;p&gt;Async generators behave much like ordinary generators.&lt;/p&gt;

&lt;p&gt;For iteration, you use async for for async generators, instead of ordinary for for ordinary generators.&lt;/p&gt;

&lt;p&gt;The example used in the previous section to demonstrate an async iterator for interaction with Redis turns out to be much simpler if we set it up as an async generator:&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>